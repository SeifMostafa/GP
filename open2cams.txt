#include "opencv2/objdetect/objdetect.hpp"
//#include "opencv2/videoio.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/stitching/stitcher.hpp"
#include <iostream>
#include <stdio.h>

using namespace std;
using namespace cv;

CascadeClassifier face_cascade;
CascadeClassifier profileFace_cascade;
CascadeClassifier body_cascade;
String window_name = "Face Detection";

void detectFaces(Mat frame) {

  std::vector<Rect> faces;
  std::vector<Rect> profile_faces;
  std::vector<Rect> profile_faces_flip;
  Mat frame_gray;
  Mat dst;

  // Convert to gray scale
  cvtColor(frame, frame_gray, COLOR_BGR2GRAY);

  // Equalize histogram
  equalizeHist(frame_gray, frame_gray);

  // Detect faces
  // Iterate over all of the faces

  profileFace_cascade.detectMultiScale(frame_gray, profile_faces, 1.1,6,
				0|CASCADE_SCALE_IMAGE, Size(10, 30));
        cout <<" profile faces"<<profile_faces.size()<<endl;
        // cout <<"frontal "<<faces.size()<<endl;

         for( size_t i = 0; i < profile_faces.size(); i++ ) {


    // Find center of faces
    Point center(profile_faces[i].x +profile_faces[i].width/2, profile_faces[i].y + profile_faces[i].height/2);

    // Draw ellipse around face
    ellipse(frame, center, Size(profile_faces[i].width/2, profile_faces[i].height/2),
	    0, 0, 360, Scalar( 255,255,0 ), 4, 8, 0 );
//check=false;


  }
flip(frame,frame, 1);
flip(frame_gray,frame_gray, 1);

        profileFace_cascade.detectMultiScale(frame_gray, profile_faces_flip, 1.1,6,
				0|CASCADE_SCALE_IMAGE, Size(10, 30));
        cout <<" profile_faces_flip"<<profile_faces_flip.size()<<endl;
        // cout <<"frontal "<<faces.size()<<endl;

         for( size_t i = 0; i < profile_faces_flip.size(); i++ ) {


    // Find center of faces
    Point center(profile_faces_flip[i].x +profile_faces_flip[i].width/2, profile_faces_flip[i].y + profile_faces_flip[i].height/2);

    // Draw ellipse around face
    ellipse(frame, center, Size(profile_faces_flip[i].width/2, profile_faces_flip[i].height/2),
	    0, 0, 360, Scalar( 255,0,0 ), 4, 8, 0 );
//check=false;


  }

  imshow( window_name, frame );
}


int main() {
     //Mat frame;
 Mat frame1,frame2;
  VideoCapture cap(0);// Open default camera
 VideoCapture cap1(0);
cap.read(frame1);
  // Load preconstructed classifier
  //profileFace_cascade.load("haarcascade_profileface.xml");
  //face_cascade.load("haarcascade_frontalface_alt.xml");
   //body_cascade.load("haarcascade_mcs_upperbody.xml");
cap1.read(frame2);
  while(cap.read(frame1)) {
      cap.read(frame1);
        cap1.read(frame2);

          int rows = max(frame1.rows, frame2.rows);
        int cols = frame1.cols + frame2.cols;
        Mat3b frame(rows, cols, Vec3b(0,0,0));
        frame1.copyTo(frame(Rect(0, 0, frame1.cols, frame1.rows)));
        frame2.copyTo(frame(Rect(frame1.cols, 0, frame2.cols, frame2.rows)));
//flip(frame,frame, 1);
    //detectFaces(frame); // Call function to detect faces
    //stitching(frame1,frame2);
    imshow( window_name, frame );
    if( waitKey(30) >= 0)    // pause
      break;
  }
  return 0;
}



